// moc-to-sidebars.mjs
import fs from 'fs';
import path from 'path';

// --- CONFIGURATION ---
const MOC_FILE_PATH = 'docs/0---moc.md';
const OUTPUT_FILE_PATH = 'sidebars.js';
const DOCS_ROOT = 'docs'; // The name of your Docusaurus docs folder

// --- TYPE DEFINITIONS (JSDOC) ---

/**
 * Represents a sidebar item for Docusaurus. Can be a simple string (doc ID)
 * or a category object.
 * @typedef {string | {
 *      type: 'category',
 *      label: string,
 *      link?: {type: 'doc', id: string},
 *      items: SidebarItem[]
 * }} SidebarItem
 */

/**
 * Represents an intermediate node parsed from a single line of the MOC.
 * @typedef {object} MocNode
 * @property {string} label - The display text for the node.
 * @property {string | null} slug - The file slug if it's a wikilink, otherwise null.
 * @property {number} indent - The indentation level of the line.
 */

/**
 * Represents an item on the parsing stack, tracking the state of the
 * hierarchy.
 * @typedef {object} StackNode
 * @property {number} indent - The indentation level of this branch.
 * @property {SidebarItem[]} items - The array of children for this branch.
 * @property {string} pathPrefix - The URL path prefix inherited from parent branches.
 */

// --- REGEX & PARSING LOGIC ---
// Captures [[slug|Label]]
const WIKILINK_REGEX = /\[\[([^|]+)\|([^\]]+)\]\]/;
// Captures content of a numbered list item
const MOC_LINE_REGEX = /^\s*[0-9\.]+\s(.+)/;

/**
 * Parses a single line from the MOC into a structured MocNode.
 * @param {string} line - A single line of text from the MOC file.
 * @returns {MocNode | null} - A parsed node, or null if the line is invalid.
 */
function parseMocLine(line) {
    const lineMatch = line.match(MOC_LINE_REGEX);
    if (!lineMatch) return null;

    const content = lineMatch[1].trim();
    const indent = line.match(/^\s*/)[0].length;

    const wikilinkMatch = content.match(WIKILINK_REGEX);
    if (wikilinkMatch) {
        return { label: wikilinkMatch[2].trim(), slug: wikilinkMatch[1].trim(), indent };
    } else {
        return { label: content, slug: null, indent };
    }
}

/**
 * The core function that transforms the MOC content into a Docusaurus sidebar structure.
 * @param {string} mocContent - The full string content of the MOC.md file.
 * @returns {SidebarItem[]} - The generated sidebar array.
 */
function generateSidebarFromMoc(mocContent) {
    const lines = mocContent.split('\n');
    /** @type {SidebarItem[]} */
    const sidebar = [];

    /** @type {StackNode[]} */
    const stack = [{ indent: -1, items: sidebar, pathPrefix: '' }];

    for (const line of lines) {
        const mocNode = parseMocLine(line);
        if (!mocNode) continue;

        // Find the correct parent in the stack by popping deeper levels
        while (mocNode.indent <= stack[stack.length - 1].indent) {
            stack.pop();
        }

        const parent = stack[stack.length - 1];
        const docId = parent.pathPrefix ? `${parent.pathPrefix}/${mocNode.slug}` : mocNode.slug;

        // Look ahead to see if this node is a branch or a leaf
        const nextLine = lines[lines.indexOf(line) + 1] || '';
        const nextLineIndent = (nextLine.match(/^\s*/) || [''])[0].length;
        const isBranch = nextLineIndent > mocNode.indent;

        /** @type {SidebarItem} */
        let sidebarItem;

        if (isBranch) {
            // It's a category (Branch Node)
            const category = {
                type: 'category',
                label: mocNode.label,
                items: [],
            };
            // If the branch node is also a wikilink, add a link property.
            if (mocNode.slug) {
                category.link = { type: 'doc', id: docId };
            }
            sidebarItem = category;
        } else {
            // It's a document link (Leaf Node)
            if (!mocNode.slug) {
                console.warn(`[WARNING] Leaf node without a wikilink found and skipped: "${mocNode.label}"`);
                continue; // Skip leaf nodes that are not links, as per your rule.
            }
            sidebarItem = docId;
        }

        parent.items.push(sidebarItem);

        if (isBranch) {
            stack.push({
                indent: mocNode.indent,
                items: sidebarItem.items,
                // The new path prefix is the docId of the category itself.
                pathPrefix: mocNode.slug ? docId : parent.pathPrefix,
            });
        }
    }
    return sidebar;
}

/**
 * Generates the full content for the `sidebars.js` file.
 * @param {SidebarItem[]} sidebarData - The parsed sidebar data structure.
 * @returns {string} - The complete, formatted file content.
 */
function generateSidebarFile(sidebarData) {
    const content = `
// @ts-check
// This file is generated by \`npm run sidebar\`. Do not edit manually.

/** @type {import('@docusaurus/plugin-content-docs').SidebarsConfig} */
const sidebars = {
  docsSidebar: ${JSON.stringify(sidebarData, null, 2)},
};

module.exports = sidebars;
    `;
    return content.trim();
}


// --- MAIN EXECUTION ---
try {
    console.log(`Reading MOC from "${MOC_FILE_PATH}"...`);
    const mocContent = fs.readFileSync(MOC_FILE_PATH, 'utf8');

    console.log('Parsing MOC and generating sidebar structure...');
    const sidebarData = generateSidebarFromMoc(mocContent);

    console.log(`Writing to "${OUTPUT_FILE_PATH}"...`);
    const fileContent = generateSidebarFile(sidebarData);
    fs.writeFileSync(OUTPUT_FILE_PATH, fileContent);

    console.log('✅ Sidebar generation complete!');
    console.log('Ensure your markdown file paths and slugs match the generated IDs.');
} catch (error) {
    console.error('❌ Failed to generate sidebar:', error);
    process.exit(1);
}